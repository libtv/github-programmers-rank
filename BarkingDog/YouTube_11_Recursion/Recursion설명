재귀
하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

우리가 어떤 문제를 재귀로 푼다는 것은 곧 귀납적인 방식으로 문제를 해결하겠다는 것이데
이 귀납적인 방식이란게 지금까지의 우리의 상식과 큰 차이가 있다.

예를 들어 어떤 문자열이 올바른 괄호 쌍인지 판단하는 문제를 짠다고 하면
여는 괄호가 나왔을 때 스택에 넣고 닫는 괄호가 나오면 스택이 비어있는지 스택의 top이 짝이 맞는지를 확인해서
각각의 상황에 따라 무언가를 해라 이런 식으로 순서에 따라 해야할 일이 정해져있는 코드를 짜왔다.

이런 방식과 귀납적인 방식은 어떤 차이가 있을까?

1부터 n까지의 n개의 도미노가 있다.
1번 도미노가 쓰러진다고 가정하면 모든 도미노가 쓰러지는데
이걸 귀납적으로 표현하면
'k번 도미노가 쓰러지면 k+1번의 도미노가 쓰러진다.' 가 참이니 모든 도미노가 쓰러진다.

재귀를 잘 이해하려면
당연하게 생각하던 절차지향적인 사고를 탈피해야 한다.

재귀 함수의 조건

특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함(Base condition)
모든 입력은 base condition 으로 수렴해야 함

재귀에 대한 정보1

함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 정해야 함
모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있음
재귀는 반복문으로 구현했을 때에 비해 코드가 간결하지만 메모리/시간에서는 손해를 봄


재귀에 대한 정보2

한 함수가 자기 자신을 여러 번 호출하게 되면 비효율적일 수 있음.
피보나치 수열?
첫째 및 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열이다.

1,1,2,3,5,8....

이미 계산한 값을 또 계산하는 경우가 많다. 그래서 시간복잡도가 엄청 늘어난다.

재귀에 대한 정보3

재귀함수가 자기 자신을 부를 때 스택 영역에 계속 누적이 됨



